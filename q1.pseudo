// Questão 1
class UnionFind {
    constructor(n) {
        // 
        // Criando array de pais onde inicialmente cada elemento aponta para
        // si mesmo (cada um é seu próprio líder)
        array parent[n]
        for (set i = 0; i < n; i = i + 1) {
            parent[i] = i
        }
        
        // Criando um array de níveis para guardar a profundidade das árvores
        // para união por nível.
        array rank[n]
        for (set i = 0; i < n; i = i + 1) {
            rank[i] = 1
        }
    }

    function find(x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]) // Compressão de caminho: todos os elementos apontam para a raiz
        }

        return parent[x]
    }
    
    function union(x, y) {
        int rootX = find(x)
        int rootY = find(y)

        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) { // Se X for maior
                // Colocamos Y "abaixo" de X, mantendo mesma altura...
                parent[rootY] = rootX 
            }
            else if (rank[rootY] > rank[rootX]) { // ... e vice-versa
                parent[rootX] = rootY
            } else { // Senão, aumentamos a árvore
                parent[rootY] = rootX
                rank[rootX] = rank[rootX] + 1
            }
        }
    }
}

function vertexInList(U, L, v) {
    // Se x pertence ao mesmo grupo dos itens na lista
    if U.find(x) == L[0] {
        return true;
    }

    return false;
}


// Questão 1.1 - Todos da lista L1 mais os que tiverem número ímpar de 
// descendentes em L1
function countDescendants(v, T, L1, U, visited) {
    int count = 0
    // Atravessando os filhos de v
    NodeEdge * edge = T.m_edges[v]
    while (edge) {
        int v2 = edge->otherVertex()
        if (visited[v2]) {
            // Se v2 já foi contado, continue
            edge = edge.next
            continue
        }
        visited[v2] = true
        if (v2 in L1_set) {
            count += 1
        }
        count += countDescendants(T, v2, L1_set, visited)
        edge = edge.next
    }
    return count
}

function createL2v1(T, L1) {
    // Função que cria L2 com vértices de T da seguinte forma:
    // Os vértices estão em L1 ou tem um número ímpar de descendentes em
    // L2.
    // 
    // Entradas:
    // T = Árvore radicada criada a partir de um grafo G
    // L1 = Lista com vértices de T
    // 
    // Retorno:
    // L2 = Lista com os vértices de acordo com as restrições


    linkedList L2 = L1 // As duas listas começam iguais
    int n = len(T) // Quantidade de elementos no grafo

    // Cria estrutura union_find pra otimizar verificações
    unionFind obj_UN = unionFind(n)

    // Pra cada v em T
    for (v = 0; v < n; v = v + 1){
        // Se v não estiver em L1
        if (!vertexInList(obj_UN, L1, v)){
            // Conta descendentes
            array visited = boolean[n]
            visited[v] = true
            count_desc = countDescendants(v, T, L1, U, visited)

            // Se tiver número ímpar de descendentes adicionamos em v2
            if (count_desc % 2 == 1) {
                L2.append(v)
            }
        }
    }

    return L2
}


// Questão 1.2 - Todos da lista L1 mais os que tiverem número ímpar de 
// ancestrais em L1
function countAncestors(v, T, L, U) {
    int count = 0

    // Subindo pela árvore até a raiz (enquanto nao acharmos um vértice
    // sem pai)
    while (v != T.parent[v]) {
        v = T.parent[v]
        if (vertexInList(U, L, v)){
            count = count + 1
        }
    }

    return count
}

function createL2v2(T, L1, L2) {
    // Função que cria L2 com vértices de T da seguinte forma:
    // Os vértices estão em L1 ou tem um número ímpar de descendentes em
    // L2.
    // 
    // Entradas:
    // T = Árvore radicada criada a partir de um grafo G
    // L1 = Lista com vértices de T
    // 
    // Retorno:
    // L2 = Lista com os vértices de acordo com as restrições
    
    linkedList L2 = L1 // As duas listas começam iguais
    int n = len(T) // Quantidade de elementos no grafo

    // Cria estrutura union_find pra otimizar verificação
    unionFind obj_UN = unionFind(n)

    // Pra cada v em T
    for (v = 0; v < n; v = v + 1){
        // Se v não estiver em L2
        if (!vertexInList(obj_UN, L2, v)){
            // Conta ancestrais
            int count_ancestors = countAncestors(v, T, L2, obj_UN)

            // Se tiver número ímpar de ancestrais adicionamos em L2
            if (count_ancestors % 2 == 1) {
                L2.append(v)
            }
        }
    }

    return L2
}


// Questão 2
// Dado um grafo direcionado fortemente conectado sem pesos e uma lista 
// L de vértices no grafo, retorne o menor caminho que passe por todos os
// vértices de L em ordem.
function caminho_vertices(v1, v2, path_len) {
    // Array que armazena caminho
    int path[path_len]
    // Começando caminho em v1
    path[0] = v1

    for (int i = 1; i < path_len; i = i + 1) {
        // Vamos para o pai do último vértice e o colocamos no caminho
        v1 = parent[v1]
        path[i] = v1
    }

    return path
}

function caminhoMinimoLista(G, L) {
    // Tamanho da lista
    int L_len = len(L)
    // Tamanho do grafo
    int G.numEdges() = len(G)
    // Lista com caminhos minimos
    linkedList minimal_path 

    for (int vertex = 0; vertex < L-len - 1; vertex = vertex = 1) {
        // Definindo começo e fim do caminho
        int start = L[vertex]
        int goal = L[vertex + 1]
        
        // Criando caminhos a partir do vértice atual
        int parent[G.numEdges()]
        int distance[G.numEdges()]
        G.bfs_spt(start, parent, distance)

        // Calulando menor caminho para os dois vértices atuais e adici
        // onando na lista
        caminho_atual = caminho_vertices(start, goal, distance[goal])
        minimal_path.append(caminho_atual)
    }

    return minimal_path
}


// Questão 3
// Dado um grafo direcionado fortemente conectado com pesos e uma lista L
// de vértices no grafo, retorne o vértice cuja maior distância de um vértice
// da lista até ele seja mínima, ou seja, retornar o vértice V de forma 
// que max{d(L[0], V ), . . . , d(L[N − 1], V )} seja mínimo.
function removeValues(values, S) {
    // Função que coloca índices, definidos pela sequência `S`, do vetor `values`
    // como inválidos (-1)
    //
    // Entradas:
    // values = Vetor com valores
    // S = Sequência (vetor) com valores para os índices que devem ser 
    // invalidados
    // 
    // Retorno:
    // values = vetor com os índices definidos em S iguais a -1
    
    int S_len = len(S)

    for (int i = 0; i < S_len; i++){
        values[S[i]] = -1
    }
}

function getMax(values) {
    // Função que encontra o maior dos valores de um vetor `values` e re
    // torna seu índice
    //
    // Entradas:
    // values = Vetor com valores
    // 
    // Retorno:
    // max_index = Índice do maior valor no vetor

    int max = values[0] // Maior valor
    int max_idx = 0 // Índice do maior valor
    int values_len = len(values) // Comprimento do vetor

    // Procurando maior valor
    for (int i = 1; i < values_len; i++){
        // Se encontrarmos valor maior que o atual, atualizamos
        if (values[i] > max) {
            max = values[i]
            max_idx = i
        }
    }

    return max_idx
}

function getMin(values) {
    // Função que encontra o menor dos valores de um vetor `values` e re
    // torna seu índice
    //
    // Entradas:
    // values = Vetor com valores
    // 
    // Retorno:
    // min_index = Índice do menor valor no vetor

    int min = values[0] // Menor valor
    int min_idx = 0 // Índice do menor valor
    int values_len = len(values) // Comprimento do vetor

    // Procurando Menor valor
    for (int i = 1; i < values_len; i++){
        // Se encontrarmos valor menor que o atual, atualizamos
        if (values[i] < min) {
            min = values[i]
            min_idx = i
        }
    }

    return min_idx
}

function verticeMinimoMaximos(G, L) {
    // Vetores para o algoritmo dijkstra
    int distance[G.numEdges()]
    int parent[G.numEdges()]

    // Sequência com a maior distãncia da lista para cada vértice
    int max[G.numEdges()]

    // Para cada vértice do grafo encontramos a maior distãncia da lista
    for (int vertex = 0; vertex < G.numEdges(); vertex++) {
        // Calcular distâncias dos vértices da lista
        dijkstra(vertex, parent, distance)

        // Mantendo apenas vértices de L no vetor de distâncias
        distance = removeValues(distance, L)

        // Pegando maior distância para o vértice atual
        max[vertex] = distance[getMax(distance)]
    }

    // Retornar o menor elemento dessa lista, que será o vértice que pro
    // curamos
    return getMin(max)
}

// Questão 4
// Dado um grafo direcionado com pesos, um caminho C e um inteiro positivo
// X, projete um algoritmo que retorne o caminho mais barato C′ com o 
// mesmo começo e fim de C de forma que a distância de qualquer vértice 
// em C′ ao seu vértice mais próximo em C não ultrapasse X.

// Dijkstra com múlitplas fontes
function dijkstraFonts(int fonts[], int parent[], int distance[]){
    // Vetor que identifica se um vértice foi verificado
    bool checked[m_numVertices];

    heap Heap; // Criando heap

    // Inicializando vértices
    for (int vertex = 0; vertex < m_numVertices; vertex++){
        parent[vertex] = -1;
        distance[vertex] = INT_MAX;
        checked[vertex] = false;
    }

    // Inicializando múltiplas fontes
    for (int vertex = 0; vertex < len(fonts); vertex++){
        parent[vertex] = vertex;
        distance[vertex] = 0;
        // Colocando fontes no heap
        heap.insert_or_update(distance[vertex], vertex);
    }
    
    while(!heap.empty()) {

        // Pegando e retirando menor elemento da fila de prioridade
        vertex v1 = heap.top().second;
        heap.pop();

        // Parando execução do algoritmo se encontrarmos um nó inalcançável a partir da origem v0
        if(distance[v1] == INT_MAX) { break; }
    
        // Percorrendo todas as arestas do vértice em questão
        EdgeNode * edge = m_edges[v1];
        while(edge) {
            vertex v2 = edge->otherVertex();
        
          // Se ainda não tivermos checado um vértice na franja
            if (!checked[v2]){
                // Pegando custo dessa aresta
                int cost = edge->cost(); //Essa implementação pra DG
                // Se a distância por esse caminho for menor que a 
                // disrtância que já temos para o vértice...
                if (distance[v1] + cost < distance[v2]) {
                    // ... o pai dele se torna a vértice em que estamos
                    // (na lista de adj.)...
                    parent[v2] = v1;
                    // ...a sua distância é atualizada...
                    distance[v2] = distance[v1] + cost;
                    // ...e ele é inserido na fila prioritária.
                    heap.insert_or_update(distance[v2], v2);

                }
            }

            edge = edge->next;
        }
    }
    
    checked[v1] = true;
}

function caminhoMaisBaratoComRestricao(G, C, X) {
    // Calculamos a distância de todos os vértices até o caminho inicial
    // C...
    int distance[G.numEdges()]
    int parent[G.numEdges()]
    G.dijkstraFonts(C, parent, distance) //TODO: Apenas alterar algoritmo de dijsktra para permitir várias fontes
    // ...e os removemos, removendo todas as suas arestas.
    for (int vertex = 0; vertex < G.numEdges(); vertex++){
        if distance[vertex] > X{
            NodeEdge * edge = m_edges[vertex]

            while (edge) {
                v_1 = edge.otherVertex()
                G.removeEdge(vertex, v1)
                edge = edge.next()
            }
        }
    }

    // Recalculando caminho com o novo grafo sem os vértice "inválidos".
    G.dijkstra(C[0], parent, distance)

    int start = C[0]
    int end = C[len(C)]

    return caminho_vertices(start, end, distance[end]) //TODO: criar outra versão da função para grafos ponderados
}

// Questão 5
