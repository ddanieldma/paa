// == Questão 1 ==
// Dado um grafo G = (V, E), uma árvore radicada T de G produzida por uma
// varredura, uma lista L1 contendo vértices dessa árvore, escreva três
// algoritmos que retornem uma lista L2 contendo vértices de forma que 
// um vértice está nessa lista se e somente se ele está em L1 ou:

// Estrutura de dados union-find
class UnionFind {
    constructor(n) {
        // 
        // Criando array de pais onde inicialmente cada elemento aponta para
        // si mesmo (cada um é seu próprio líder)
        array parent[n]
        for (set i = 0; i < n; i = i + 1) {
            parent[i] = i
        }
        
        // Criando um array de níveis para guardar a profundidade das árvores
        // para união por nível.
        array rank[n]
        for (set i = 0; i < n; i = i + 1) {
            rank[i] = 1
        }
    }

    function find(x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]) // Compressão de caminho: todos os elementos apontam para a raiz
        }

        return parent[x]
    }
    
    function union(x, y) {
        int rootX = find(x)
        int rootY = find(y)

        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) { // Se X for maior
                // Colocamos Y "abaixo" de X, mantendo mesma altura...
                parent[rootY] = rootX 
            }
            else if (rank[rootY] > rank[rootX]) { // ... e vice-versa
                parent[rootX] = rootY
            } else { // Senão, aumentamos a árvore
                parent[rootY] = rootX
                rank[rootX] = rank[rootX] + 1
            }
        }
    }
}

// Função que verifica se um determinado elemento `x` pertence à lista
// `L`, utilizando objeto union-find `U` para otimizar verificação. Os con
// junto definido pela lista tem como representante o primeiro elemento 
// da lista
function elementInList(U, L, x) {
    // Se x pertence ao mesmo grupo dos itens na lista verdadeiro. Caso
    // contrário, falso
    U.find(x) == L[0] ? return true : return false // Operador ternário
}


// ==== Questão 1.1 - Possui um número ímpar de descendentes em L2. ====

// Função que conta vértices de `T`, descendentes de `v`, que 
// pertencem a `L`, utilizando objeto union-find `U` e vetor `visited` para 
// maior eficiência
function countDescendants(v, T, L, U, visited) {
    // Contagem de descendentes
    int count = 0

    // Percorrendo os filhos de v
    NodeEdge * edge = T.m_edges[v]
    while (edge) {
        // Pegando filho de v, v_2
        int v2 = edge->otherVertex()
        
        // Se v_2 já foi contado, continue
        if (visited[v2]) {
            edge = edge.next
            continue
        }

        // Se não, dizemos que foi contado
        visited[v2] = true
        // E se estiver na lista incrementamos a contagem
        if (elementInList(U, L, v)) {
            count += 1
        }
        count += countDescendantsv(v2, T, L, U, visited)
        edge = edge.next
    }
    
    return count
}

function createL2v1(T, L1) {
    // Função que cria L2 com vértices de T da seguinte forma:
    // Os vértices estão em L1 ou tem um número ímpar de descendentes em
    // L2.
    // 
    // Entradas:
    // T = Árvore radicada criada a partir de um grafo G
    // L1 = Lista com vértices de T
    // 
    // Retorno:
    // L2 = Lista com os vértices de acordo com as restrições


    // As duas listas começam iguais
    LinkedList L2
    L2.copyList(L1)

    // Quantidade de elementos no grafo
    int n = len(T)

    // Cria estrutura union_find pra otimizar verificações
    unionFind obj_UN = unionFind(T.numEdges())

    // Pra cada vértice v_i em T
    for (v_i = 0; v_i < n; v_i += 1){
        // Se v_i não estiver em L1
        if (!elementInList(obj_UN, L1, v_i)){
            // Contamos seus descendentes
            array visited = boolean[T.numEdges()]
            visited[v_i] = true
            numDescendants = countDescendants(v_i, T, L1, U, visited)

            // Se tiver número ímpar de descendentes adicionamos em v2
            if (numDescendants % 2 == 1) {
                L2.append(v_i)
            }
        }
    }

    return L2
}


// Questão 1.2 - Todos da lista L1 mais os que tiverem número ímpar de 
// ancestrais em L1

// Função que conta vértices de `T`, ancestrais de `v`, que 
// pertencem a `L`, utilizando objeto union-find `U` para maior eficiência
function countAncestors(v, T, L, U) {
    int count = 0

    // Subindo pela árvore até a raiz (enquanto nao acharmos um vértice
    // sem pai)
    while (v != T.parent[v]) {
        v = T.parent[v]
        if (elementInList(U, L, v)){
            count++
        }
    }

    return count
}

function createL2v2(T, L1, L2) {
    // Função que cria L2 com vértices de T da seguinte forma:
    // Os vértices estão em L1 ou tem um número ímpar de descendentes em
    // L2.
    // 
    // Entradas:
    // T = Árvore radicada criada a partir de um grafo G
    // L1 = Lista com vértices de T
    // 
    // Retorno:
    // L2 = Lista com os vértices de acordo com as restrições
    
    LinkedList L2 = L1 // As duas listas começam iguais
    int n = len(T) // Quantidade de elementos no grafo

    // Cria estrutura union_find pra otimizar verificação
    unionFind obj_UN = unionFind(n)

    // Pra cada v em T
    for (v = 0; v < n; v += 1){
        // Se v não estiver em L2
        if (!vertexInList(obj_UN, L2, v)){
            // Conta ancestrais
            int count_ancestors = countAncestors(v, T, L2, obj_UN)

            // Se tiver número ímpar de ancestrais adicionamos em L2
            if (count_ancestors % 2 == 1) {
                L2.append(v)
            }
        }
    }

    return L2
}


// Questão 2
// Dado um grafo direcionado fortemente conectado sem pesos e uma lista 
// L de vértices no grafo, retorne o menor caminho que passe por todos os
// vértices de L em ordem.

// Função que, dados dois vértices `v_1` e `v_2` e o comprimento `pathLen`
// do caminho entre eles, retorna vetor com sequência de vértices que 
// define o caminho C começado em `v_1` e terminado em `v_2`
function caminhoVertices(v1, v2, pathLen) {
    // Array que armazena caminho
    int path[pathLen]
    
    // Começando caminho em v1
    path[0] = v1

    // Preenchendo caminho
    for (int i = 1; i < pathLen; i += 1) {
        // Vamos para o pai do último vértice e o colocamos no caminho
        v1 = parent[v1]
        path[i] = v1
    }

    return path
}

function caminhoMinimoLista(G, L) {
    // Função que cria menor caminho que passa por todos os vértices de L
    // em ordem.
    // 
    // Entradas:
    // G = Grafo direcionado fortemente conectado
    // L = Lista de vértices
    // 
    // Retorno:
    // minimalPath = Menor caminho que passe por todos os vértices de L
    
    // Lista com caminhos minimos
    LinkedList minimalPath 

    // Para
    for (int vertex = 0; vertex < G.numEdges() - 1; vertex += 1) {
        // Definindo começo e fim do caminho
        int start = L[vertex]
        int goal = L[vertex + 1]
        
        // Criando caminhos a partir do vértice atual
        int parent[G.numEdges()]
        int distance[G.numEdges()]
        G.bfs(start, parent, distance)

        // Calculando menor caminho para os dois vértices atuais e adici
        // onando na lista
        currentPath = caminhoVertices(start, goal, distance[goal])
        minimalPath.append(currentPath)
    }

    return minimalPath
}


// Questão 3
// Dado um grafo direcionado fortemente conectado com pesos e uma lista L
// de vértices no grafo, retorne o vértice cuja maior distância de um vértice
// da lista até ele seja mínima, ou seja, retornar o vértice V de forma 
// que max{d(L[0], V ), . . . , d(L[N − 1], V )} seja mínimo.
function removeValues(values, S) {
    // Função que coloca índices, definidos pela sequência `S`, do vetor `values`
    // como inválidos (-1)
    //
    // Entradas:
    // values = Vetor com valores
    // S = Sequência (vetor) com valores para os índices que devem ser 
    // invalidados
    // 
    // Retorno:
    // values = vetor com os índices definidos em S iguais a -1
    
    int S_len = len(S)

    for (int i = 0; i < S_len; i++){
        values[S[i]] = -1
    }
}

function getMax(values) {
    // Função que encontra o maior dos valores de um vetor `values` e re
    // torna seu índice
    //
    // Entradas:
    // values = Vetor com valores
    // 
    // Retorno:
    // max_index = Índice do maior valor no vetor

    int max = values[0] // Maior valor
    int max_idx = 0 // Índice do maior valor
    int values_len = len(values) // Comprimento do vetor

    // Procurando maior valor
    for (int i = 1; i < values_len; i++){
        // Se encontrarmos valor maior que o atual, atualizamos
        if (values[i] > max) {
            max = values[i]
            max_idx = i
        }
    }

    return max_idx
}

function getMin(values) {
    // Função que encontra o menor dos valores de um vetor `values` e re
    // torna seu índice
    //
    // Entradas:
    // values = Vetor com valores
    // 
    // Retorno:
    // min_index = Índice do menor valor no vetor

    int min = values[0] // Menor valor
    int min_idx = 0 // Índice do menor valor
    int values_len = len(values) // Comprimento do vetor

    // Procurando Menor valor
    for (int i = 1; i < values_len; i++){
        // Se encontrarmos valor menor que o atual, atualizamos
        if (values[i] < min) {
            min = values[i]
            min_idx = i
        }
    }

    return min_idx
}

function verticeMinimoMaximos(G, L) {
    // Vetores para o algoritmo dijkstra
    int distance[G.numEdges()]
    int parent[G.numEdges()]

    // Sequência com a maior distãncia da lista para cada vértice
    int max[G.numEdges()]

    // Para cada vértice do grafo encontramos a maior distãncia da lista
    for (int vertex = 0; vertex < G.numEdges(); vertex++) {
        // Calcular distâncias dos vértices da lista
        dijkstra(vertex, parent, distance)

        // Mantendo apenas vértices de L no vetor de distâncias
        distance = removeValues(distance, L)

        // Pegando maior distância para o vértice atual
        max[vertex] = distance[getMax(distance)]
    }

    // Retornar o menor elemento dessa lista, que será o vértice que pro
    // curamos
    return getMin(max)
}

// Questão 4
// Dado um grafo direcionado com pesos, um caminho C e um inteiro positivo
// X, projete um algoritmo que retorne o caminho mais barato C′ com o 
// mesmo começo e fim de C de forma que a distância de qualquer vértice 
// em C′ ao seu vértice mais próximo em C não ultrapasse X.

// Dijkstra com múlitplas fontes
function dijkstraFonts(int fonts[], int parent[], int distance[]){
    // Vetor que identifica se um vértice foi verificado
    bool checked[m_numVertices];

    heap Heap; // Criando heap

    // Inicializando vértices
    for (int vertex = 0; vertex < m_numVertices; vertex++){
        parent[vertex] = -1;
        distance[vertex] = INT_MAX;
        checked[vertex] = false;
    }

    // Inicializando múltiplas fontes
    for (int vertex = 0; vertex < len(fonts); vertex++){
        parent[vertex] = vertex;
        distance[vertex] = 0;
        // Colocando fontes no heap
        heap.insert_or_update(distance[vertex], vertex);
    }
    
    while(!heap.empty()) {

        // Pegando e retirando menor elemento da fila de prioridade
        vertex v1 = heap.top().second;
        heap.pop();

        // Parando execução do algoritmo se encontrarmos um nó inalcançável a partir da origem v0
        if(distance[v1] == INT_MAX) { break; }
    
        // Percorrendo todas as arestas do vértice em questão
        EdgeNode edge = m_edges[v1];
        while(edge) {
            vertex v2 = edge->otherVertex();
        
          // Se ainda não tivermos checado um vértice na franja
            if (!checked[v2]){
                // Pegando custo dessa aresta
                int cost = edge->cost(); //Essa implementação pra DG
                // Se a distância por esse caminho for menor que a 
                // disrtância que já temos para o vértice...
                if (distance[v1] + cost < distance[v2]) {
                    // ... o pai dele se torna a vértice em que estamos
                    // (na lista de adj.)...
                    parent[v2] = v1;
                    // ...a sua distância é atualizada...
                    distance[v2] = distance[v1] + cost;
                    // ...e ele é inserido na fila prioritária.
                    heap.insert_or_update(distance[v2], v2);

                }
            }

            edge = edge->next;
        }
    }
    
    checked[v1] = true;
}

function caminhoMaisBaratoComRestricao(G, C, X) {
    // Calculamos a distância de todos os vértices até o caminho inicial
    // C...
    int distance[G.numEdges()]
    int parent[G.numEdges()]
    G.dijkstraFonts(C, parent, distance) //TODO: Apenas alterar algoritmo de dijsktra para permitir várias fontes
    // ...e os removemos, removendo todas as suas arestas.
    for (int vertex = 0; vertex < G.numEdges(); vertex++){
        if distance[vertex] > X{
            NodeEdge * edge = m_edges[vertex]

            while (edge) {
                v_1 = edge.otherVertex()
                G.removeEdge(vertex, v1)
                edge = edge.next()
            }
        }
    }

    // Recalculando caminho com o novo grafo sem os vértice "inválidos".
    G.dijkstra(C[0], parent, distance)

    int start = C[0]
    int end = C[len(C)]

    return caminho_vertices(start, end, distance[end]) //TODO: criar outra versão da função para grafos ponderados
}

// Questão 5
// Dado um grafo não direcionado conexo com pesos, retorna a aresta cuja remoção
// causaria o maior aumento no custo da árvore geradora mínima
function adicionaGrafoUN(U, G) {
    for (int vertex = 1; vertex < G.numEdges; vertex++) {
        U.union(vertex - 1, vertex)
    }
}

function removeEdgeAndFindSubgraphs(graph, v_i, v_j) {
    // Removendo a aresta
    graph.removeEdge(v_i, v_j)
    
    // Encontrando os dois subgrafos
    adjList subgraph_1 = graph.bfs(v_i)
    adjList subgraph_2 = graph.bfs(v_j)

    // Recolocando a aresta
    graph.addEdge(v_i, v_j)
    
    // Retornando vetor com os dois subgrafos
    adjList subgraphs = {subgraph_1, subgraph_2}
    return subgraphs
}

function findMinEdgeBetweenSubgraphs(graph, subgraph_1, subgraph_2) {
    // Colocando os dois subgrafos em estrutura union-find
    // Criand estrutura union-find
    UnionFind obj_UN = UnionFind(len(subgraph_1)) + len(subgraph_2)
    // Adicionando vértices dos grafos
    adicionaGrafoUN(obj_UN, subgraph_1)
    adicionaGrafoUN(obj_UN, subgraph_2)

    // Lista encadeada para armazenar arestas que pertencem ao corte
    LinkedList validEdges

    // Iterando sobre vértices do grafo original
    for (int v_i = 1; v_i < G.numEdges; v_i++) {
        // Pegando arestas de v_i
        EdgeNode edge = G.m_edges[v_i]
        
        // Iterando sobre arestas de v_i
        while (edge) {
            // Pegando outro vértice v_j
            v_j = edge.otherVertex()
            
            // Se os dois vértices estiverem em subgrafos diferentes
            if obj_UN.find(v_i) != obj_UN.find(v_j) {
                // Criando array com dois vértices e custo da aresta para
                // representar aresta única
                int onlyEdge = {v_i, v_j, edge.cost()}
                // Colocando na lista
                validEdges.append(onlyEdge)
            }

            // Próxima aresta
            edge = edge.next()
        }
    }

    // Encontrando menor das arestas
    // Pegando começo da lista
    LinkedListNode edge = validEdges.head()

    // Definindo custo mais barato e sua respectiva aresta como primeiro
    // elemento da lista
    int cheapestCost = edge.value[2]
    int cheapestEdge = {edge.value[0]. edge.value[1]}
    
    // Indo para o segundo elemento da lista
    edge = edge.next()
    
    // Percorrendo a lista
    while (edge) {
        // Se encontrarmos uma aresta mais barato atualizamos variáveis
        if (edge.cost() > cheapestCost) {
            int cheapestCost = edge.value[2]
            int cheapestEdge = {edge.value[0]. edge.value[1]}
        }

        // Próxima aresta
        edge = edge.next()
    }

    return cheapestEdge
}

function max_costIncrease(graph, mst) {
    int maxIncrease = 0 // Maior diferença
    int maxEdge = {0, 0, 0} // Aresta que causou maior diferença
    
    // Pra cada vértice na MST
    for (int v_i = 0; v_i < G.numEdges(); v_i++){
        // Pegando arestas de v_i
        EdgeNode edge = mst.m_edges[v_i]
        
        while (edge) {
            // Pegando o outro vértice v_j
            v_j = edge.otherVertex()

            // Peso da aresta atual
            int currentWeight = edge.cost()

            // Calculando diferença de custo com a retirada da aresta.
            // Removendo a aresta (v_i, v_j) de T e encontrando subgrafos gerados
            adjList subgraphs = removeEdgeAndFindSubgraphs(mst, v_i, v_j)
            // Removendo a aresta também do grafo original
            graph.removeEdge(v_i, v_j)
            // Encontrando a aresta mínima entre os dois subgrafos
            int minEdge[3] = findMinEdgeBetweenSubgraphs(graph, subgraphs[0], subgraphs[1])
            // Recolocando aresta no grafo original
            graph.addEdge(v_i, v_j)
            // Calculando a diferença de custo...
            int costIncrease = minEdge[2] - currentWeight
            // ... e fazendo atualizações caso a diferença seja menor
            if (costIncrease > max_increase){
                maxIncrease = costIncrease
                maxEdge = minEdge
            }
            
            // Próxima aresta
            edge = edge.next()
        }
    }

    // Retornando aresta que causou maior aumento no custo
    return maxEdge
}